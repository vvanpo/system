
Definitions:
------------
	- Driver:
		A driver is a module that directs (via output) and interprets (via
		input) an external device or resource.  A module that only interprets
		and translates input from a device is not a driver.
		e.g.:
			- VGA driver
			- USB driver
			- SATA driver
	- Module:
		A module is a program that has a distinct purpose, a distinct interface,
		and does not accept input that is not consistent with its interface.
		Modules are often small and statically-linked, and have clearly-defined
		dependencies.
	- Block driver:
		A block driver is a device driver that exposes a file of fixed length,
		and can be written to and read from.  Many backing stores are exposed
		via block drivers.
		e.g. SATA driver
/*
	- Blob server:
		A blob server is a module that deduplicates and tracks stored data,
		and serves the data as "blobs" of bytes, along with the hash of that
		blob and its length in bytes.  A blob server can take and store its
		data potentially across multiple block files.
	- File server:
		A file server is a module that sits atop a blob server and handles
		blob metadata by organizing blobs into files.  The file server counts
		references to blobs and garbage collects any unreferenced blobs.
		File servers also handle block and character files.
	- Page-cache:
		The page-cache is a kernel structure of pages cached in memory.
		Different backing stores have different policies for syncing and
		flushing the cache; a block driver will likely flush its portion of the
		cache often.

Files:
------
	Although a hierarchical filesystem could be implemented atop the file
	server, no system software is dependent on it.

	Files are exposed to the user as a unique id, with no other metadata.
	Attributes can optionally extend a file, via calls to the file server.

	Some special file servers include a tmpfs and a cachefs.  The tmpfs ensures
	files never touch a persistent backing store, while the cachefs keeps files
	in an LRU and frees up space when there is pressure to do so.  A cachefs
	could also be a tmpfs.

	File servers must carry some well-defined guarantee on consistency.

File cache:
-----------
	

Processes:
----------
	A process is a snapshot of a program binary, mapped into a virtual address
	space. Processes serve only to act on files.

	Mandatory access control is implemented for each process: processes have a
	set of visible files, and child processes have their set of files chosen by
	their parent.

	Processes aim to survive reboots (i.e. have their private COW binary copy
	on a persistent backing store), with ephemeral resources stored on temporary
	filesystems to signify that processes should always check their
	condition before use.

Process trees & init-system:
----------------------------

Process loader:
---------------
	The binary format specifies addresses relative to segments, and the start
	addresses of each segment are chosen by the loader.  The segments are
	addressed directly in the system language as well, to ease the programming
	of multiple threads/stacks, and prevent the need for knowledge of the
	system's page size.

System calls:
-------------
	Only file-handling calls: read and write.

	Extra system functions are available via file manipulations within a
	pseudo-filesystem.  This way a parent process can easily restrict a child
	process to a set of system functions, by only giving it visibility to
	specific system files.

	I/O calls take as parameters the hash of the file in question, the address
	of the string to be read or written, the length of said string, and the
	address they are to be read or written into.  Optional parameters can
	specify the blocking behaviour of the call.
*/

Drivers:
--------
	Binaries for hardware drivers are selected by the kernel and get special
	file mappings that represent ranges of DMA addresses.

Character set:
--------------
	ASCII/Unicode has some annoyances, in particular the messy mingling of
	control codes with printable characters.  I would prefer a single control
	escape code, with a separate mapping table of control codes, and less
	ambiguity in said codes (no 8 bazillion codes for whitespace, each with
	idiosyncratic and unsemantic effects).

	One option for a character set would simply be the set of all printable
	characters in the unicode spec, with the only whitespace being newline and
	space.  Terminals could use newline (perhaps being code point 0) as an
	escape code, and shells and editors could escape newline inputs.
	The other option is to build control codes into the character set by
	defining code point 0 as an escape code.  In either case, the set of all
	defined code points 1 and up can be mapped to a typeface.

	I prefer the first option because it simplifies stored text and the
	options are essentially the same anyway.  Formatted text could be easily
	read by raw text editors, and easily converted to raw text by removing
	escape codes.

	Formatted text could be written in a raw editor by having every escape
	code on its own line, or alternatively using the '\' character as a
	delimiter.
	e.g. "This is an example of \2\formatted text\2\:\0\\1\In this example,
		escape code 1 is a tab, and escape code 2 delimits bold text.  The \\
		character is used to delimit escape codes in a quoted string, but such
		a string needs to be processed to raw text first, by replacing every
		presence of '\\<num>\\' with '<newline><num>'."
	To ease writing formatted text in a raw editor, shortcuts like \0,1\ could
	be made to concatenate escape codes.

Cache:
------
	A write-back cache of all data used and stored by the system.  The
	filesystem determines how pages in the cache get written 
