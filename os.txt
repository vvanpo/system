
Definitions:
------------
	- Driver:
		A driver is a module that directs (via output) and interprets (via
		input) an external device or resource.  A module that only interprets
		and translates input from a device is not a driver.
		e.g.:
			- VGA driver
			- USB driver
			- SATA driver
	- Module:
		A module is a program that has a distinct purpose, a distinct interface,
		and does not accept input that is not consistent with its interface.
		Modules are often small and statically-linked, and have clearly-defined
		dependencies.
	- Block driver:
		A block driver is a device driver that exposes a file of fixed length,
		and can be written to and read from.  Many backing stores are exposed
		via block drivers.
		e.g. SATA driver

Processes:
----------
	A process is a snapshot of a program binary, mapped into a virtual address
	space. Processes serve only to act on files.

	Mandatory access control is implemented for each process: processes have a
	set of visible files, and child processes have their set of files chosen by
	their parent.

	Processes aim to survive reboots (i.e. have their private COW binary copy
	on a persistent backing store), with ephemeral resources stored on temporary
	filesystems to signify that processes should always check their
	condition before use.

Process trees & init-system:
----------------------------

Process loader:
---------------
	The binary format specifies addresses relative to segments, and the start
	addresses of each segment are chosen by the loader.  The segments are
	addressed directly in the system language as well, to ease the programming
	of multiple threads/stacks, and prevent the need for knowledge of the
	system's page size.

Drivers:
--------
	Binaries for hardware drivers are selected by the kernel and get special
	file mappings that represent ranges of DMA addresses.

Character set:
--------------
	ASCII/Unicode has some annoyances, in particular the messy mingling of
	control codes with printable characters.  I would prefer a single control
	escape code, with a separate mapping table of control codes, and less
	ambiguity in said codes (no 8 bazillion codes for whitespace, each with
	idiosyncratic and unsemantic effects).

	One option for a character set would simply be the set of all printable
	characters in the unicode spec, with the only whitespace being newline and
	space.  Terminals could use newline (perhaps being code point 0) as an
	escape code, and shells and editors could escape newline inputs.
	The other option is to build control codes into the character set by
	defining code point 0 as an escape code.  In either case, the set of all
	defined code points 1 and up can be mapped to a typeface.

	I prefer the first option because it simplifies stored text and the
	options are essentially the same anyway.  Formatted text could be easily
	read by raw text editors, and easily converted to raw text by removing
	escape codes.

	Formatted text could be written in a raw editor by having every escape
	code on its own line, or alternatively using the '\' character as a
	delimiter.
	e.g. "This is an example of \2\formatted text\2\:\0\\1\In this example,
		escape code 1 is a tab, and escape code 2 delimits bold text.  The \\
		character is used to delimit escape codes in a quoted string, but such
		a string needs to be processed to raw text first, by replacing every
		presence of '\\<num>\\' with '<newline><num>'."
	To ease writing formatted text in a raw editor, shortcuts like \0,1\ could
	be made to concatenate escape codes.

Cache:
------
	A write-back cache of all data used and stored by the system.  The
	filesystem determines how pages in the cache get written to the backing
	store.

Streams & Files:
----------------
	Files are conceptualized by a process as a mutable list of bytes.  Every
	file opened by a process gets its own segment; any writes to that segment
	result in writes to the file.
	As mutable lists, files can be prepended or appended, new slices can be
	inserted into the file, or slices can be overwritten.
	Hence, files can act as queues (pipes) or stacks.
	Files have no metadata, other than a uniquely identifying number that does
	not change for the life of the file.

System call:
------------
	The system call available to processes is the 'open' call, which takes a
	file's unique id as its argument, and returns a new segment with the file's
	contents.

