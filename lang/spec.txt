
1-to-1 mapping of bytecode <-> language syntax/semantics:
    - Bytecode hence includes complete variable list
    - Build a bytecode translator to C and/or ELF/SysV
    - Build a virtual machine for ELF/SysV?
    - Literate programming: embedded documentation/specification that defines
      aspects of each function, and restricts/adds checks for how certain
      objects can be used.
    - Preprocessor: more than just macros---the prepocessor adds most of the
      safety checks and syntax.  Essentially a scripting language that defines
      how the program gets compiled.  Safety is implemented by the
      preprocessor---the bare language is not safe in any way.
    - Preprocessing steps must be serialized and appended to bytecode to
      facilitate unpacking the bytelang file back into full source code.
    - Compiled programs should have their APIs easily accessible, e.g. a simple
      shell function should be all that's needed to query or unit-test any
      public API of a binary or bytelang program, and return the results in a
      meaningful format.  Consistent APIs would therefore solve problems common
      to shell programming, where program output is idiosyncratic, unstable
      across program versions, and difficult to parse with many edge cases.
      Environment variables and command-line flags (being the usual method of
      input for most programs) would be replaced by simple API definitions.
      Automated documentation would be common across source code and user manual
      pages.  This encourages every program to spend time on API design and
      allow all programs to easily double as shareable libraries.
    - Environment variables are annoying versions of globals, and should be
      ignored/not implemented.

Bytecode compiler:
    - Warnings default to compilation error, must be turned off individually to
      complete compilation with warnings.
        - Endian-specific code generates a warning, compiler must be able to
          catch:
            - word-sized operations on addresses with byte-assigned data
            - byte-sized operations on addresses with word-assigned data
            - non-deterministic pointer values, say from stream input, can
              result in these warnings if there are no alignment checks
              (depending on the operation(s))
    - No such thing as compiler flags, only pragmas.  All compiler options must
      be specified within the code (e.g. turning off certain warnings), this
      ensures verifiable builds.  A consequence is that all compiler
      optimizations must be well-defined and baked-in to the source code of
      every program that wants to use them.
    - If we ever pass the 2^8 code limit, a simple method of increasing the
      range is to map each to code to a rune---a "runecode" rather than a
      "bytecode"---and encode in UTF-8.
    - Generated bytecode is gzipped into .bytelang files.
        - Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
          be made to automatically uncompress and disassemble the bytecode into
          the language, and recompile when edited and saved.
    - Address translation needs to be transparent.  Address translation is
      required for architectures that don't allow use of the full address
      space (e.g. x86-64 non-canonical addresses) or operating systems that
      prohibit use of specific memory regions (e.g. Windows NT).
    - Stack address references are limited to the owning stack segment, and
      globals.  Initializing a new thread hence breaks lexical
      scoping---variables must be passed as parameters to the new stack.
    - An expression is defined to be a sequence of instructions that places one
      or more return values at the bottom of the stack.  Expressions may or may
      not have side-effects.
    - Anything that does not have a return value is called a statment.
    - Variables in bytecode don't have an associated identifier, but simply an
      address offset from the frame pointer of the local function.  Non-local
      variables must first dereference the frame pointer, so operations with
      non-local operands require one or more extra dereference operations in
      their definition.

Native compiler:
    - To make a portable language, we need word sizes to potentially be as small
      as a byte
        - Allocating 2^32 bytes is possible on a 64-bit architecture, but not
          32-bit or smaller: such code isn't portable
        - Even allocating a mere 2^8 bytes isn't possible for some
          architectures, but perfectly reasonable and necessary for others
        - We could implement an on-the-fly "address-space-loader" to extend the
          address space beyond the architecture's word-size, but this could
          break programs that abitrarily run or change its own code, and would
          be reliant on an OS
        - Instead, we consider this a limit of the design, and thus such
          programs are not truly portable

Namespace hierarchy:
    - Taken from Golang:
        - a block structure can have variables offset into itself, just like C
          structs
        - if block "sym1" has block "sym2" nested within it, and "sym2" has
          "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
          and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:
    bytelang = global_function
    WORD = ? 64-bit sequence ?
    global_function = function
        statement = ( bFunction, function )
                    | ( bAllocate, allocate )
                    | ( bDeallocate, deallocate )
                    | ( bAssignment, assignment )
                    | ( bThread, thread )
                    | ( bIf, if )
                    | bReturn
            function = number_statements, statement+
                number_statements = WORD
            allocate = length
                length = WORD
            deallocate = length
            assignment = address, length, expression
                address = global | ( bAddress, WORD )
                global = ( bStackPointer, offset )
                        | ( bFramePointer, offset )
                        | ( bInstructionPointer )
                    offset = WORD
            thread = function_call
            if = condition, number_statements, statement+
                condition = expression
        expression = ( bFunctionCall, function_call )
                    | ( bReference, reference )
                    | ( bDereference, dereference )
                    | ( bLiteral, literal )
                    | operations
            function_call = WORD
            reference = WORD
            dereference = address, length
            literal = WORD+
            operations = op, length
                op = bNot | bAnd | bOr | bXor | bShiftL | bLShiftR | bAShiftR
                    | bAdd | bSubtract | bMultiply | bDivideFloor | bExponent
                    | bModulo

Bytecode semantics:
    - Variables are represented by a single address, and have no length
      information associated with them.  Operations determine reference
      granularity.
    - Space for variables are allocated at the point where they are defined.
      Conditional execution of some expressions means stack-frames aren't a
      well-defined length for each function.
    - Implicit global variables are not locked to a specific stack-allocated
      address offset:
        '_sp'   stack pointer: '_sp' is updated with each allocation and
                deallocation of the stack.
        '_fp'   frame pointer: like the stack pointer, _fp is automatically
                updated on function calls.
        '_ip'   instruction pointer: can be used to implement jumps by
                assigning address to '_ip'.
    - All globals are local to the owning stack segment when referenced.
    - Assigning to or reading from globals must be of length word.
    - Expressions return a value by placing it at the bottom of the stack, but
      require the space to be allocated beforehand:
        - function call:    modifies return and argument variables previously
                            allocated by the caller
        - reference:        copies literal address value onto stack
        - dereference:      copies value pointed to by address onto the stack,
                            requires length argument
        - literal:          variable-sized compile-time value copied onto stack
        - not:              modifies operand in-place
        - and, or, xor, shiftl, lshiftr, ashiftr, add, subtract, multiply,
          divide floor, exponent, modulo:
                            overwrites first operand, and dellocates the second
    - Binary operations require operands to be of equal length.
    - To copy return values into a variable, a stack pointer offset and length
      is passed to an assignment statement.
    - Only function calls and statements can have side-effects.  No other
      expressions do.
    - Stack-frame diagram:

        caller_local    |
        ------------    |
        return_vars     |   grows down
        args*           |
        fp              v
        ret_address
        callee_local
        ------------

        - *In many cases, a function can defined to use the same variable as
          both a parameter and a return value.
        - Arguments are pushed onto the stack backwards (i.e. last argument pushed
          first).

Standard library:
    - Eval:
        - It's not feasible to embed an interpreter into the runtime of every
          process
        - Instead, the standard library can implement eval in tiers, by
          optionally loading a full language interpreter, a bytecode compiler,
          and/or a native compiler into the runtime.  Lastly, a 'bare' eval
          implementation would simply consist of copying native code into the
          heap and pointing the instruction pointer to the right address.  In
          this way, a REPL could be built with minimal overhead by using a
          secondary program to compile input, and passing it to the process.
    - Different tiers of eval simply packages that make up the compiler
      itself, as the entire compiler toolchain should be self-hosted within the
      language's own standard library.  This would make it very easy to build
      tools for development, by reusing modules for compiling and parsing.
    - Ideally, it should be possible to compile a runtime that doesn't require
      an underlying operating system, hence the standard library should contain
      packages that implement a microkernel.  This microkernel should be
      modular enough to allow for configurable complexity, i.e. whether or not
      to allow for multiprocessing, shared libraries/dynamic linking, etc.  Such
      a kernel could even be extended to implement a hypervisor or full
      operating system.

Address translation:
--------------------
	- Translation allows for a portable, consistent representation of the
	  call stack across all architectures, with the native compiler
	  optimizing out the details.
	- A compiler pragma could allow for a real address to pass through
	  bytecode-to-native compilation, in the special case where systems code
	  (drivers, kernel code, etc.) needs to access a special memory
	  location.
	- Bytecode operates on multiple fictional address spaces, as segments.
	  Such segments allow the programmer to let the native compiler worry
	  about page-alignment and space constraints.
	- Segments are represented as a list of bytes that can be prepended or
	  appended using segment operators.  This is useful for files that get
	  mapped into new segments, and requiring segment operators to extend or 
	  shrink segments allows the compiler to ensure no overflows occur.

Error handling:
---------------
	- Functions have a tree of all possible inputs and outputs, with
	  allowable conditions assigned to each.
	- The compiler implements runtime checks on ranges when needed.  This can
	  be avoided when the caller of a function has output ranges that match
	  the input ranges of the function, for example.
	- When conditions fail for a dynamic input, the tree of conditions
	  contains a pointer to an error recovery function.

asmlang grammar:
----------------

	name = [a-zA-z]+
	number = [0-9a-fA-F]+
	offset = uuid = number
	address = ((name | uuid) ":" number) | (("_ip" | "_sp" | "_fp") [offset])
	length = number | "-"
	expression = call | ref | deref | literal | operation
		call = "call" address
		ref = "ref" address
		deref = "deref" address length
		literal = "literal" number length
		operation = ("not" | "and" | "or" | "xor" | ...) length
	statement = open | close | push | pop | copy | ifzero
		open = "open" (name | ([name] uuid))
		close = "close" (name | uuid)
		push = "push" expression
		pop = "pop" [number] [address [length offset]]
		copy = "copy" expression address
		ifzero = "ifzero" expression address

	- 'offset' is in granularities of word-size.
	- When the 'length' argument is a hyphen, it denotes the architecture's
	  word-size.
	- A new process has two automatic segments, a stack for the execution of
	  "main", and a code segment.
	- Each thread has its own _ip, _sp, and _fp.  Initially, the first thread
	  of a process has the values _ip = code:0, and _sp = _fp = main:0.

