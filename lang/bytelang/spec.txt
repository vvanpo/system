
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes complete variable list
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?
	- Literate programming: embedded documentation/specification that defines
	  aspects of each function, and restricts/adds checks for how certain
	  objects can be used.
	- Preprocessor: more than just macros---the prepocessor adds most of the
	  safety checks and syntax.  Essentially a scripting language that defines
	  how the program gets compiled.

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to
	  complete compilation with warnings
		- Endian-specific code generates a warning, compiler must be able to
		  catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can
			  result in these warnings if there are no alignment checks
			  (depending on the operation(s))
	- No such thing as compiler flags, only pragmas.  All compiler options must
	  be specified within the code (e.g. turning off certain warnings), this
	  ensures verifiable builds.  A consequence is that all compiler
	  optimizations must be well-defined and baked-in to the source code of
	  every program that wants to use them.
	- If we ever pass the 2^8 code limit, a simple method of increasing the
	  range is to map each to code to a rune---a "runecode" rather than a
	  "bytecode"---and encode in UTF-8
	- To make a portable language, we need word sizes to potentially be as small
	  as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not
		  32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some
		  architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the
		  address space beyond the architecture's word-size, but this could
		  break programs that abitrarily run or change its own code, and would
		  be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such
		  programs are not truly portable
		- A header in the bytecode file indicates what the minimum architecture
		  specification need to be
	- Generated bytecode is gzipped into .bytelang files
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
		  be made to automatically uncompress and disassemble the bytecode into
		  the language, and recompile when edited and saved
	- Address translation needs to be transparent.  Address translation is
	  required for architectures that don't allow use of the full address
	  space (e.g. x86-64 non-canonical addresses) or operating systems that
	  prohibit use of specific memory regions (e.g. Windows NT).  Translation
	  allows the programmer to keep the illusion that he/she has complete control
	  the entire 64-bit (or whatever word-length) region, and doesn't need to
	  worry about registers.  It allows for a portable, consistent
	  representation of the call stack across all architectures, with the
	  native compiler optimizing out the details.
	- A compiler pragma could allow for a real address to pass through
	  bytecode-to-native compilation, in the special case where systems code
	  (drivers, kernel code, etc.) needs to access a special memory location.
	- Code is data.  Pre-defined functions are literals, just as any other pre-
	  defined data is.
	- No formal segments are used to partition up the (fictional) address
	  space of the bytecode file.  Programmers are free to define their own
	  segments, and must set up their own stack by assigning a value to _sp
	  (usually the highest address, to start).  The end of the list of
	  literals is considered the last address loaded into memory, and
	  everything above is uninitialized, or what is commonly known as "the
	  heap".  This last address is the first literal in the literal list, so
	  that any statement can make use of it.

Namespace hierarchy:
	- Taken from Golang:
		- a bBlock structure can have variables offset into itself, just like C
		  structs
		- if bBlock "sym1" has bBlock "sym2" nested within it, and "sym2" has
		  "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
		  and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:

	bytelang = header, identifier_list, namespace_tree, literal_list
	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"		# determines the length of WORD
	identifier_list = number_identifiers, special_identifiers, ( identifier, "\n" )*
		number_identifiers = WORD
		special_identifiers = "_\n_sp\n_fp\n_ip\n"
		identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
	namespace_tree = namespace					# the root namespace defines the start function and the module name
		namespace = id_number, identifier_index, number_members, member*
			id_number = WORD					# id_number uniquely identifies a variable, but multiple namespace patterns can resolve to the same id_number (for members of block variables)
			identifier_index = WORD
			number_members = WORD
			member = namespace
	literal_list = heap_address, ( literal )+
		heap_address = literal_value			# length of a word, as it is an address.  Represents start of the heap, i.e. 1 + bytelang file-length in bytes
		literal = statement | expression
			statement = ( bVariable, variable ) | function_call | if | assignment | return
				variable = namespace_index, type
					namespace_index = WORD		# references id_number in namespace_tree
					type = bByte | bWord | block
						block = bBlock, number_bytes, number_members, member_variable*
							number_bytes = WORD
							number_members = WORD
							member_variable = byte_offset, literal_index
								byte_offset = WORD
				function_call = bFunctionCall, callee, argument*, return_assignment*
					callee = expression			# usually a reference, or a pre-defined function
					argument = expression
					return_assignment = reference
				if = bIf, expression, number_statements, statement+
				assignment = bAssignment, receiver, expression
					receiver = reference
				return = bReturn
			expression = literal_pointer, literal_value, ( bReference, reference ), function, unary_operation, binary_operation
				literal_pointer = bLiteralPointer, literal_index
					literal_index = WORD
				literal_value = bLiteralValue, number_bytes, BYTE+	# big-endian order
				reference = namespace_index
				function = bFunction, number_params, variable*, number_return, variable*, number_statements, statement+
					number_params = WORD
					number_return = WORD
					number_statements = WORD
				unary_operation = address_reference | ( unary_operator, expression )
					address_reference = bAddressReferenceOp, reference
					unary_operator = bDereferenceOp | bNotOp
				binary_operation = binary_operator, expression, expression
					binary_operator = bAddOp
										| bSubtractOp
										| bMultiplyOp
										| bDivideFloorOp
										| bExponentOp
										| bModuloOp
										| bAndOp
										| bOrOp
										| bXorOp
										| bRotateLeftOp
										| bRotateRightOp

Stack frame diagram:

	caller_local    |
	-----           |	grows down
	args            |
	fp              v
	ret
	-----
	callee_local
	
	Return variables are local variables of the caller, and are allocated
	before the function call.  They can even be used and assigned before the
	function call, but are overwritten during the call.

