
1-to-1 mapping of bytecode <-> language syntax/semantics:
    - Bytecode hence includes complete variable list
    - Build a bytecode translator to C and/or ELF/SysV
    - Build a virtual machine for ELF/SysV?
    - Literate programming: embedded documentation/specification that defines
      aspects of each function, and restricts/adds checks for how certain
      objects can be used.
    - Preprocessor: more than just macros---the prepocessor adds most of the
      safety checks and syntax.  Essentially a scripting language that defines
      how the program gets compiled.  Safety is implemented by the
      preprocessor---the bare language is not safe in any way.
    - Preprocessing steps must be serialized and appended to bytecode to
      facilitate unpacking the bytelang file back into full source code.
    - Compiled programs should have their APIs easily accessible, e.g. a simple
      shell function should be all that's needed to query or unit-test any
      public API of a binary or bytelang program, and return the results in a
      meaningful format.  Consistent APIs would therefore solve problems common
      to shell programming, where program output is idiosyncratic, unstable
      across program versions, and difficult to parse with many edge cases.
      Environment variables and command-line flags (being the usual method of
      input for most programs) would be replaced by simple API definitions.
      Automated documentation would be common across source code and user manual
      pages.  This encourages every program to spend time on API design and
      allow all programs to easily double as shareable libraries.
    - Environment variables are annoying versions of globals, and should be
      ignored/not implemented.

Bytecode compiler:
    - Warnings default to compilation error, must be turned off individually to
      complete compilation with warnings.
        - Endian-specific code generates a warning, compiler must be able to
          catch:
            - word-sized operations on addresses with byte-assigned data
            - byte-sized operations on addresses with word-assigned data
            - non-deterministic pointer values, say from stream input, can
              result in these warnings if there are no alignment checks
              (depending on the operation(s))
    - No such thing as compiler flags, only pragmas.  All compiler options must
      be specified within the code (e.g. turning off certain warnings), this
      ensures verifiable builds.  A consequence is that all compiler
      optimizations must be well-defined and baked-in to the source code of
      every program that wants to use them.
    - If we ever pass the 2^8 code limit, a simple method of increasing the
      range is to map each to code to a rune---a "runecode" rather than a
      "bytecode"---and encode in UTF-8.
    - Generated bytecode is gzipped into .bytelang files.
        - Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
          be made to automatically uncompress and disassemble the bytecode into
          the language, and recompile when edited and saved.
    - Address translation needs to be transparent.  Address translation is
      required for architectures that don't allow use of the full address
      space (e.g. x86-64 non-canonical addresses) or operating systems that
      prohibit use of specific memory regions (e.g. Windows NT).
    - Translation allows for a portable, consistent representation of the call
      stack across all architectures, with the native compiler optimizing out
      the details.
    - A compiler pragma could allow for a real address to pass through
      bytecode-to-native compilation, in the special case where systems code
      (drivers, kernel code, etc.) needs to access a special memory location.
    - Bytecode operates on multiple fictional address spaces, as segments.
      Such segments allow the programmer to let the native compiler worry
      about page-alignment and space constraints.  Each thread stack gets their
      own address space, as defined by the word-length in the file header. The
      heap is overlaid on all stack segments, meaning no special
      segment-referencing needs to take place to access the heap.  Each stack
      is simply initialized to begin at address ~0, and the heap always begins
      at address 0.
    - Variable references are limited to the owning stack segment, and
      globals.  Initializing a new thread hence breaks lexical
      scoping---variables must be passed as parameters to the new stack.
    - Code is data.  Pre-defined functions are literals on the heap, just as any
      other pre-defined data is.

Native compiler:
    - To make a portable language, we need word sizes to potentially be as small
      as a byte
        - Allocating 2^32 bytes is possible on a 64-bit architecture, but not
          32-bit or smaller: such code isn't portable
        - Even allocating a mere 2^8 bytes isn't possible for some
          architectures, but perfectly reasonable and necessary for others
        - We could implement an on-the-fly "address-space-loader" to extend the
          address space beyond the architecture's word-size, but this could
          break programs that abitrarily run or change its own code, and would
          be reliant on an OS
        - Instead, we consider this a limit of the design, and thus such
          programs are not truly portable

Namespace hierarchy:
    - Taken from Golang:
        - a block structure can have variables offset into itself, just like C
          structs
        - if block "sym1" has block "sym2" nested within it, and "sym2" has
          "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
          and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:

    bytelang = header, global_function
    header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
        pseudo_architecture = ( "0" ... "9" )+, " bytes/word"       # determines the length of WORD
    global_function = local_allocation, variable_table, number_statements, statement+
    expression = static_expr | dynamic_expr
        static_expr = ( bFunction, function )
                     | ( bReference, reference )
                     | ( bLiteral, literal )
            function = caller_allocation, local_allocation, variables, number_statements, statement+
                caller_allocation = length          # caller chooses to satisfy all, part, or none.  See semantics below.
                    length = WORD                   # length in words
                local_allocation = length
                variables = variable_table, args
                    # indices start at the first address of the caller allocation
                    variable_table = number_variables, ( variable_index, start_address, identifier, 0 )*    # identifier is null-terminated
                        variable_index = WORD       # table index, starts at 1 (0 is reserved to signify parent table)
                        start_address = WORD        # offset from start of caller allocation, can't exceed concatenation of caller+local allocations
                        identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
                    args = number_returns, return_index*, number_parameters, parameter_index*
                        number_returns = WORD
                        return_index = WORD
                        number_parameters = WORD
                        parameters_index = WORD
                number_statements = WORD
            reference = variable_index*             # 0 signifies parent table, so the first non-0 index ends the search
            literal = number_bytes, BYTE+
                number_bytes = WORD
        dynamic_expr = unary_op | binary_op
            unary_op = ( bDereferenceOp | bNotOp ), length, expression
            binary_op = ( bAddOp
                      | bSubtractOp
                      | bMultiplyOp
                      | bDivideFloorOp
                      | bExponentOp
                      | bModuloOp
                      | bAndOp
                      | bOrOp
                      | bXorOp
                      | bRotateLeftOp
                      | bRotateRightOp ), length, expression, length, expression
    statement = ( bAssignment, assignment )
              | ( bFunctionCall, function_call )
              | ( bThread, thread )
              | ( bIf, if )
              | bReturn
        assignment = address, expression
            address = static_expr
        function_call = caller_allocation, args, callee
            callee = address
        thread = function_call
        if = condition, number_statements, statement+
            condition = expression

Bytecode semantics:

    - Variable references search in the local table first, then the parent,
      etc, up to the global table.
    - Variables represent a single address, and have no length information
      associated with them.  Operations determine reference granularity.
    - Space for variables are allocated at the point where they are defined.
      Conditional execution of some expressions means stack-frames aren't a
      well-defined length for each function.
    - An implicit global table has special variables not locked to a specific
      stack-allocated address offset:
        '_'     discard value: when passed as a return value to a function, the
                value is ignored and cannot be referenced.
        '_sp'   stack pointer: '_sp' is updated with each allocation and
                deallocation of the stack.
        '_fp'   frame pointer: like the stack pointer, _fp is automatically
                updated on function calls.
        '_ip'   instruction pointer: can be used to implement jumps by
                assigning address to '_ip'.
    - All globals are local to the owning stack segment when referenced.
    - There is no distinction between "statement" and "expression", everything
      is just called an expression.  However, there is a clear distinction
      between expressions with strictly compile-time side-effects (static
      expressions) versus those with possible run-time side-effects (dynamic
      expressions).
    - Static expressions have deterministic values, and side-effects are
      evident within the program binary.
    - Dynamic expressions consist of operations on either static or dynamic
      expressions.
    - The return value of any expression is a memory address, usually that of
      the stored value that was operated on.
    - Stack-frame diagram:

        caller_local    |
        ------------    |
        return_vars     |   grows down
        args*           |
        fp              v
        ret_address
        callee_local
        ------------

        - Return variables are local variables of the caller when possible, and
          otherwise are temporary variables which are copied into the assigned local
          variables of the caller.
        - *In many cases, a function can defined to use the same variable as
          both a parameter and a return value.
        - Arguments are pushed onto the stack backwards (i.e. last argument pushed
          first).

