
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes complete variable list
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?
	- Literate programming: embedded documentation/specification that defines
	  aspects of each function, and restricts/adds checks for how certain
	  objects can be used.
	- Preprocessor: more than just macros---the prepocessor adds most of the
	  safety checks and syntax.  Essentially a scripting language that defines
	  how the program gets compiled.  Safety is implemented by the
	  preprocessor---the bare language is not safe in any way.
	- Preprocessing steps must be serialized and appended to bytecode to
	  facilitate unpacking the bytelang file back into full source code.
	- Compiled programs should have their APIs easily accessible, e.g. a simple
	  shell function should be all that's needed to query or unit-test any
	  public API of a binary or bytelang program, and return the results in a
	  meaningful format.  Consistent APIs would therefore solve problems common
	  to shell programming, where program output is idiosyncratic, unstable
	  across program versions, and difficult to parse with many edge cases.
	  Environment variables and command-line flags (being the usual method of
	  input for most programs) would be replaced by simple API definitions.
	  Automated documentation would be common across source code and user manual
	  pages.  This encourages every program to spend time on API design and
	  allow all programs to easily double as shareable libraries.
	- Environment variables are annoying versions of globals, and should be
	  ignored/not implemented.

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to
	  complete compilation with warnings.
		- Endian-specific code generates a warning, compiler must be able to
		  catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can
			  result in these warnings if there are no alignment checks
			  (depending on the operation(s))
	- No such thing as compiler flags, only pragmas.  All compiler options must
	  be specified within the code (e.g. turning off certain warnings), this
	  ensures verifiable builds.  A consequence is that all compiler
	  optimizations must be well-defined and baked-in to the source code of
	  every program that wants to use them.
	- If we ever pass the 2^8 code limit, a simple method of increasing the
	  range is to map each to code to a rune---a "runecode" rather than a
	  "bytecode"---and encode in UTF-8.
	- Generated bytecode is gzipped into .bytelang files.
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
		  be made to automatically uncompress and disassemble the bytecode into
		  the language, and recompile when edited and saved.
	- Address translation needs to be transparent.  Address translation is
	  required for architectures that don't allow use of the full address
	  space (e.g. x86-64 non-canonical addresses) or operating systems that
	  prohibit use of specific memory regions (e.g. Windows NT).
	- Translation allows for a portable, consistent representation of the call
	  stack across all architectures, with the native compiler optimizing out
	  the details.
	- A compiler pragma could allow for a real address to pass through
	  bytecode-to-native compilation, in the special case where systems code
	  (drivers, kernel code, etc.) needs to access a special memory location.
	- Bytecode operates on multiple fictional address spaces, as segments.
	  Such segments allow the programmer to let the native compiler worry
	  about page-alignment and space constraints.  Each thread stack gets their
	  own address space, as defined by the word-length in the file header. The
	  heap is overlaid on all stack segments, meaning no special
	  segment-referencing needs to take place to access the heap.  Each stack
	  is simply initialized to begin at address ~0, and the heap always begins
	  at address 0.
	- Variable references are limited to the owning stack segment, and
	  globals.  Initializing a new thread hence breaks lexical
	  scoping---variables must be passed as parameters to the new stack.
	- Code is data.  Pre-defined functions are literals on the heap, just as any
	  other pre-defined data is.

Native compiler:
	- To make a portable language, we need word sizes to potentially be as small
	  as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not
		  32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some
		  architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the
		  address space beyond the architecture's word-size, but this could
		  break programs that abitrarily run or change its own code, and would
		  be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such
		  programs are not truly portable

Namespace hierarchy:
	- Taken from Golang:
		- a block structure can have variables offset into itself, just like C
		  structs
		- if block "sym1" has block "sym2" nested within it, and "sym2" has
		  "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
		  and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:

	bytelang = header, global_function
	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"		# determines the length of WORD
	global_function = local_allocation, variable_table, number_statements, statement+		# starting function doesn't require any caller allocation
	expression = static_expr | dynamic_expr
		static_expr = ( bFunction, function )
					 | ( bReference, reference )
					 | ( bLiteral, literal )
			function = caller_allocation, local_allocation, variables, number_statements, statement+
				caller_allocation = length			# caller chooses to satisfy all, part, or none.  See semantics below.
					length = WORD 					# length in words
				local_allocation = length
				variables = variable_table, args
					# indices start at the first address of the caller allocation
					variable_table = number_variables, ( variable_index, start_address, identifier, 0 )*	# identifier is null-terminated
						variable_index = WORD		# table index, starts at 1 (0 is reserved to signify parent table)
						start_address = WORD		# offset from start of caller allocation, can't exceed concatenation of caller+local allocations
						identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
					args = number_returns, return_index*, number_parameters, parameter_index*
						number_returns = WORD
						return_index = WORD
						number_parameters = WORD
						parameters_index = WORD
				number_statements = WORD
			reference = variable_index*			    # 0 signifies parent table, so the first non-0 index ends the search
			literal = number_bytes, BYTE+
				number_bytes = WORD
		dynamic_expr = unary_op | binary_op
			unary_op = ( bDereferenceOp | bNotOp ), length, expression
            binary_op = ( bAddOp
                      | bSubtractOp
                      | bMultiplyOp
                      | bDivideFloorOp
                      | bExponentOp
                      | bModuloOp
                      | bAndOp
                      | bOrOp
                      | bXorOp
                      | bRotateLeftOp
                      | bRotateRightOp ), length, expression, length, expression
	statement = ( bAssignment, assignment )
			  | ( bFunctionCall, function_call )
			  | ( bThread, thread )
			  | ( bIf, if )
			  | bReturn
		assignment = address, expression
			address = static_expr
		function_call = caller_allocation, args, callee
			callee = address
		thread = function_call
		if = condition, number_statements, statement+
			condition = expression

Bytecode semantics:

	- variable references search in the local table first, then the parent,
	  etc, up to the global table.
	- variables represent a single address, and have no length information
	  associated with them.  Operations choose their reference granularity.
	- an implicit global table has special variables not locked to a specific
	  stack-allocated address offset:
		'_'		discard value: when passed as a return value to a function, the
				value is ignored and cannot be referenced.
		'_sp'	stack pointer: '_sp' is updated with each allocation and
				deallocation of the stack.
		'_fp'	frame pointer: like the stack pointer, _fp is automatically
				updated on function calls.
		'_ip'	instruction pointer: can be used to implement jumps by
				assigning address to '_ip'.
	- all globals are local to the owning stack segment when referenced.
	- function calls must be preceded by the necessary stack allocation for
	  arguments and return values, as defined by the function.  By placing
	  local variables in the correct order and at the bottom of the stack, a
	  caller can optimize a function call by no requiring temporary stack
	  space.
	- Expressions return variable-sized data, and can have side effects:
		- function expressions have the side effect of placing a block of
		  instructions on the heap, and return the address at which it is
		  placed
		- variable references return a word representing an absolute address
		- literals return a variable-sized sequence of bytes
		- operations (except dereference) require defining the length of their
          return values

Stack frame diagram:

	------------
	callee_local
	ret_address
	fp              ^
	args**          |
	return_vars*    |	grows up
	------------    |
	caller_local    |

	*Return variables are local variables of the caller when possible, and
	otherwise are temporary variables which are copied into the assigned local
	variables of the caller.
	**In a special case, a function can defined to use the same variable as both
	a parameter and a return value, in which case no extra stack space is
	allocated for either when possible, or a single temporary location is
	allocated and copied to the caller's local variable assigned by the call.

