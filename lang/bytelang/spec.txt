
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes complete variable list
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?
	- Literate programming: embedded documentation/specification that defines
	  aspects of each function, and restricts/adds checks for how certain
	  objects can be used.
	- Preprocessor: more than just macros---the prepocessor adds most of the
	  safety checks and syntax.  Essentially a scripting language that defines
	  how the program gets compiled.

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to
	  complete compilation with warnings
		- Endian-specific code generates a warning, compiler must be able to
		  catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can
			  result in these warnings if there are no alignment checks
			  (depending on the operation(s))
	- No such thing as compiler flags, only pragmas.  All compiler options must
	  be specified within the code (e.g. turning off certain warnings), this
	  ensures verifiable builds.  A consequence is that all compiler
	  optimizations must be well-defined and baked-in to the source code of
	  every program that wants to use them.
	- If we ever pass the 2^8 code limit, a simple method of increasing the
	  range is to map each to code to a rune---a "runecode" rather than a
	  "bytecode"---and encode in UTF-8
	- To make a portable language, we need word sizes to potentially be as small
	  as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not
		  32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some
		  architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the
		  address space beyond the architecture's word-size, but this could
		  break programs that abitrarily run or change its own code, and would
		  be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such
		  programs are not truly portable
		- A header in the bytecode file indicates what the minimum architecture
		  specification need to be
	- Generated bytecode is gzipped into .bytelang files
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
		  be made to automatically uncompress and disassemble the bytecode into
		  the language, and recompile when edited and saved
	- Address translation needs to be transparent.  Address translation is
	  required for architectures that don't allow use of the full address
	  space (e.g. x86-64 non-canonical addresses) or operating systems that
	  prohibit use of specific memory regions (e.g. Windows NT).  Translation
	  allows the programmer to keep the illusion that he/she has complete control
	  the entire 64-bit (or whatever word-length) region, and doesn't need to
	  worry about registers.  It allows for a portable, consistent
	  representation of the call stack across all architectures, with the
	  native compiler optimizing out the details.
	- A compiler pragma could allow for a real address to pass through
	  bytecode-to-native compilation, in the special case where systems code
	  (drivers, kernel code, etc.) needs to access a special memory location.
	- Code is data.  Pre-defined functions are literals, just as any other pre-
	  defined data is.
	- No formal segments are used to partition up the (fictional) address
	  space of the bytecode file.  Programmers are free to define their own
	  segments, and must set up their own stack by assigning a value to _sp
	  (usually the highest address, to start).  The end of the list of
	  literals is considered the last address loaded into memory, and
	  everything above is uninitialized, or what is commonly known as "the
	  heap".  This last address is the first literal in the literal list, so
	  that any statement can make use of it.

Namespace hierarchy:
	- Taken from Golang:
		- a bBlock structure can have variables offset into itself, just like C
		  structs
		- if bBlock "sym1" has bBlock "sym2" nested within it, and "sym2" has
		  "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
		  and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:

	bytelang = header, identifier_list, statement_list
	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"		# determines the length of WORD
	identifier_list = number_identifiers, special_identifiers, ( identifier, "\n" )*
		number_identifiers = WORD
		special_identifiers = "_\n_sp\n_fp\n_ip\n"
		identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
	statement_list = number_statements, heap_address, ( statement )+
		number_statements = WORD
		heap_address = assignment		# type bWord, as it is an address.  Represents start of the heap, i.e. 1 + bytelang file-length in bytes
		statement = ( bVariable, variable )
					| ( bFunctionCall, function_call )
					| ( bIf, if )
					| ( bAssignment, assignment )
					| bReturn
			variable = identifier_index, type
				identifier_index = WORD
				type = bWord | bByte | block
					block = bBlock, number_bytes, number_members, member_variable*
						number_bytes = WORD
						number_members = WORD
						member_variable = byte_offset, statement_index
							byte_offset = WORD
							statement_index = WORD
			function_call = callee, argument*, receiver*
				callee = expression			# usually a reference, or a pre-defined function
				argument = expression
				receiver = reference		# function calls return values by assigning them to existing local variable in the caller's stack
			if = condition, number_statements, statement_index+
				condition = expression
			assignment = receiver, expression
		expression = ( bLiteral, literal )
					| ( bReference, reference )
					| ( bFunction, function )
					| unary_operation
					| binary_operation
			literal = number_bytes, BYTE+	# big-endian order
			reference = statement_index
			function = number_params, reference*, number_return, reference*, number_statements, statement_index+
				number_params = WORD
				number_return = WORD
			unary_operation = address_reference | ( unary_operator, expression )
				address_reference = bAddressReferenceOp, reference
				unary_operator = bDereferenceOp | bNotOp
			binary_operation = binary_operator, expression, expression
				binary_operator = bAddOp
									| bSubtractOp
									| bMultiplyOp
									| bDivideFloorOp
									| bExponentOp
									| bModuloOp
									| bAndOp
									| bOrOp
									| bXorOp
									| bRotateLeftOp
									| bRotateRightOp

Stack frame diagram:

	caller_local    |
	-----           |	grows down
	args            |
	fp              v
	ret
	-----
	callee_local
	
	Return variables are local variables of the caller, and are allocated
	before the function call.  They can even be used and assigned before the
	function call, but are overwritten during the call.

