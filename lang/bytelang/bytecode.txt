
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes variable table
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to
	  complete compilation with warnings
		- Endian-specific code generates a warning, compiler must be able to
		  catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can
			  result in these warnings if there are no alignment checks
			  (depending on the operation(s))
	- If we ever pass the 2^8 code limit, a simple method of increasing the
	  range is to map each to code to a rune---a "runecode" rather than a
	  "bytecode"---and encode in UTF-8
	- To make a portable language, we need word sizes to potentially be as small
	  as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not
		  32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some
		  architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the
		  address space beyond the architecture's word-size, but this could
		  break programs that abitrarily run or change its own code, and would
		  be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such
		  programs are not truly portable
		- A header in the bytecode file indicates what the minimum architecture
		  specification need to be
	- Generated bytecode is gzipped into .bytelang files
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can
		  be made to automatically uncompress and disassemble the bytecode into
		  the language, and recompile when edited and saved
	- Address translation needs to be transparent.  Address translation is
	  required for architectures that don't allow use of the full address
	  space (e.g. x86-64 non-canonical addresses) or operating systems that
	  prohibit use of specific memory regions (e.g. Windows NT).  Translation
	  allows the programmer to keep the illusion that he/she has complete control
	  the entire 64-bit (or whatever word-length) region, and doesn't need to
	  worry about registers.  It allows for a portable, consistent
	  representation of the call stack across all architectures, with the
	  native compiler optimizing out the details.
	- A compiler pragma could allow for a real address to pass through
	  bytecode-to-native compilation, in the special case where systems code
	  (drivers, kernel code, etc.) needs to access a special memory location.
	- Code is data.  Pre-defined functions are literals, just as any other pre-
	  defined data is.
	- Each function is its own literal.  Each variable is also its own literal,
	  and points to the literal representings its initial value.  A named
	  function therefore consists of a variable pointing to a function literal.
	- No formal segments are used to partition up the (fictional) address
	  space of the bytecode file.  Programmers are free to define their own
	  segments, and must set up their own stack by assigning a value to _sp
	  (usually the highest address, to start).  The end of the list of
	  literals is considered the last address loaded into memory, and
	  everything above is uninitialized, or what is commonly known as "the
	  heap".  This last address is the first literal in the literal list, so
	  that any statement can make use of it.

Variable namespaces:
	- Taken from Golang:
		- a bBlock* structure can have variables offset into itself, just like C
		  structs
		- if bBlock* "sym1" has bBlock* "sym2" nested within it, and "sym2" has
		  "sym3" as a nested variable, then if "sym3" is unique to both "sym2"
		  and "sym1" it can be referenced directly from "sym1": "sym1.sym3"

Bytecode grammar:

	bytelang = header, identifier_list, literal_list
	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"		# determines the length of WORD
	identifier_list = number_identifiers, special_identifiers, ( identifier, "\n" )*
		number_identifiers = WORD
		special_identifiers = "_\n_sp\n_fp\n_ip\n"
		identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
	literal_list = heap_address, start_function, ( literal )+
		heap_address = bytes					# length of a word, as it is an address.  Represents start of the heap, i.e. 1 + bytelang file-length in bytes
		start_function = function				# start function: _ip is initialized to the corresponding address.  Return statement exits program.
		literal = variable | function | bytes
			variable = bVariable, identifier_index, owner_index, declaration
				identifier_index = WORD
				owner_index = WORD				# owning function, to determine scope
				declaration = 
			function = 
				statement = variable_def | if | assignment | jump | return
				expression = bExpression, ( bytes | variable_ref | function_call | operation )
					call = 
					operation = 
			bytes = bBytes, number_bytes, BYTE+		# big-endian order
				number_bytes = WORD

#	file = header, identifier_list, variable_table, import_table, statement_list, literal_list
#
#	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
#		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"
#	identifier_list = number, special_identifiers, ( identifier, "\n" )*
#	variable_table = number, special_variables, ( identifier_number )*
#	import_table = number, ( variable_number )*
#	statement_list = number, Statement+
#	literal_list = ( number, number+ )*
#
#	Statement = VariableDef | If | Assignment | Jump | Return
#		VariableDef = bVariableDef, Declaration, variable_number, number
#			Declaration = variable_number, ( bWord | bByte | BlockWord | BlockByte )
#				BlockWord = bBlockWord, number
#				BlockByte = bBlockByte, number
#		If = bIf, Expression, statement_list
#		Assignment = bAssignment, number, variable_number+, ( Expression | Function)
#		Jump = bJump, Expression
#		Return = bReturn
#			Function = bFunction, number_params, VariableDef*, number_retval, ( bWord | bByte | BlockWord | Blockyte )*, statement_list
#			Expression = bExpression, ( Literal | VariableRef | FunctionCall | Operation )
#				Literal = bLiteral, number
#				VariableRef = bVariableRef, variable_number
#				FunctionCall = bFunctionCall, ( VariableRef | Function ), Expression+
#				Operation = ( bReferenceOp
#							| bDereferenceOp
#							| bAddOp
#							| bSubtractOp
#							| bMultiplyOp
#							| bDivideOp
#							| bExponentOp
#							| bModuloOp
#							| bAndOp
#							| bOrOp
#							| bXorOp
#							| bNotOp
#							| bRotateLeftOp
#							| bRotateRightOp ), Expression+

Stack frame diagram:

	caller_local    |
	-----           |	grows down?
	args            |
	fp              v
	ret
	-----
	callee_local
	
	Return variables are local variables of the caller, and are allocated
	before the function call.  They can even be used and assigned before the
	function call, but are overwritten during the call.

