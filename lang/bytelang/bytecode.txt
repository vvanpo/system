
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes symbol table
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to complete compilation with warnings
		- Endian-specific code generates a warning, compiler must be able to catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can result in these warnings if there are no alignment checks (depending on the operation(s))
	- In case more than 2^8 codes are expected, a simple method of increasing the range is to map each to code to a rune---a "runecode" rather than a "bytecode"---and encode in UTF-8
	- To make a portable language, we need word sizes to potentially be as small as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not 32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the address space beyond the architecture's word-size, but this could break programs that abitrarily run or change its own code, and would be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such programs are not truly portable
		- A header in the bytecode file indicates what the minimum architecture specification need to be: the header is of the format "<# bits per word>\n"
	- Generated bytecode is gzipped into .bytelang files
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can be made to automatically uncompress and disassmble the bytecode into the language, and recompile when edited and saved

Symbol namespaces:
	- Taken from Golang:
		- a bBlock* structure can have symbols offset into itself, just like C structs
		- if bBlock* "sym1" has bBlock* "sym2" nested within it, and "sym2" has "sym3" as a nested symbol, then if "sym3" is unique to both "sym2" and "sym1" it can be referenced directly from "sym1": "sym1.sym3"
	- All symbols, external or not, are stored in symbol table

Bytecode grammar:

	file = header, identifier_list, symbol_table, import_table, start_bytecode, literal_list

	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"
	identifier_list = special_identifiers, ( identifier, "\n" )+
	symbol_table = number, special_symbols, ( identifier_number, address )+
	import_table = number, ( identifier_number )*
	start_bytecode = number, ( SymbolDef )+
	literal_list = ( number, number+ )*

	SymbolDef = bSymbolDef, number, ( Automatic | Address | Offset )
		Automatic = bAutomatic, Declaration
		Address = bAddress, Declaration, Expression
		Offset = bOffset, ( ( Automatic, number ) | Address | Offset ), number, Declaration
		Declaration = ( bWord | bByte | BlockWord | BlockByte | Function )
			BlockWord = bBlockWord, number
			BlockByte = bBlockByte, number
			Function = bFunction, number_params, ( bWord | bByte | BlockWord | BlockByte )* number_retval> ( bWord | bByte | BlockWord | Blockyte )* number bytecode
				bytecode = ( If | Assignment | Jump | Return )+
					If = Expression, number, bytecode
					Assignment = number_assignees, number+, Expression
					Jump = bJump, Expression
					Return = bReturn
		Expression = bExpression, ( Literal | SymbolRef | FunctionCall | Operation )
			Literal = bLiteral, number
			SymbolRef = bSymbolRef, number
			FunctionCall = bFunctionCall, Expression+
			Operation = bOperation, ( bReferenceOp
									| bDereferenceOp
									| bAddOp
									| bSubtractOp
									| bMultiplyOp
									| bDivideOp
									| bExponentOp
									| bModuloOp
									| bAndOp
									| bOrOp
									| bXorOp
									| bNotOp
									| bRotateLeftOp
									| bRotateRightOp ), Expression+

	identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
	identifier_number = number
	address = number
	number = WORD
	number_params = BYTE
	number_retval = BYTE

	special_identifiers = "_\n_sp\n_fp\n_ip\n_text\n_data\n"
	special_symbols = 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0	// Each value 1 word in width
