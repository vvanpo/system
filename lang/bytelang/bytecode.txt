
1-to-1 mapping of bytecode <-> language syntax/semantics:
	- bytecode hence includes variable table
	- Build a bytecode translator to C and/or ELF/SysV
	- Build a virtual machine for ELF/SysV?

Bytecode compiler:
	- Warnings default to compilation error, must be turned off individually to complete compilation with warnings
		- Endian-specific code generates a warning, compiler must be able to catch:
			- word-sized operations on addresses with byte-assigned data
			- byte-sized operations on addresses with word-assigned data
			- non-deterministic pointer values, say from stream input, can result in these warnings if there are no alignment checks (depending on the operation(s))
	- In case more than 2^8 codes are expected, a simple method of increasing the range is to map each to code to a rune---a "runecode" rather than a "bytecode"---and encode in UTF-8
	- To make a portable language, we need word sizes to potentially be as small as a byte
		- Allocating 2^32 bytes is possible on a 64-bit architecture, but not 32-bit or smaller: such code isn't portable
		- Even allocating a mere 2^8 bytes isn't possible for some architectures, but perfectly reasonable and necessary for others
		- We could implement an on-the-fly "address-space-loader" to extend the address space beyond the architecture's word-size, but this could break programs that abitrarily run or change its own code, and would be reliant on an OS
		- Instead, we consider this a limit of the design, and thus such programs are not truly portable
		- A header in the bytecode file indicates what the minimum architecture specification need to be: the header is of the format "<# bits per word>\n"
	- Generated bytecode is gzipped into .bytelang files
		- Because of 1-to-1 bytecode-language mapping, a vim/editor plugin can be made to automatically uncompress and disassmble the bytecode into the language, and recompile when edited and saved
	- Address translation needs to be transparent.  Address translation is
	  required for architectures that don't allow use of the full address
	  space (e.g. x86-64 non-canonical addresses) or operating systems that
	  prohibit use of specific memory regions (e.g. Windows NT).  Translation
	  allows the programmer to keep the illusion that he/she has complete control
	  the entire 64-bit region.

Variable namespaces:
	- Taken from Golang:
		- a bBlock* structure can have variables offset into itself, just like C structs
		- if bBlock* "sym1" has bBlock* "sym2" nested within it, and "sym2" has "sym3" as a nested variable, then if "sym3" is unique to both "sym2" and "sym1" it can be referenced directly from "sym1": "sym1.sym3"
	- All variables, external or not, are stored in variable table

Bytecode grammar:

	file = header, identifier_list, variable_table, import_table, start_bytecode, literal_list

	header = "Version 0.0\nArch.: ", pseudo_architecture, "\n"
		pseudo_architecture = ( "0" ... "9" )+, " bytes/word"
	identifier_list = number, special_identifiers, ( identifier, "\n" )*
	variable_table = number, special_variables, ( identifier_number )*
	import_table = number, ( variable_number )*
	start_bytecode = number, Statement+
	literal_list = ( number, number+ )*

	Statement = VariableDef | If | Assignment | Jump | Return
		VariableDef = Automatic | Address | Offset
			Automatic = bAutomatic, Declaration
			Address = bAddress, Declaration, Expression
			Offset = bOffset, variable_number, offset_number, Declaration
			Declaration = variable_number, ( bWord | bByte | BlockWord | BlockByte | Function )
				BlockWord = bBlockWord, number
				BlockByte = bBlockByte, number
				Function = bFunction, number_params, ( bWord | bByte | BlockWord | BlockByte )* number_retval ( bWord | bByte | BlockWord | Blockyte )* number Statement+
		If = bIf, Expression, number, Statement+
		Assignment = bAssignment, number, variable_number+, Expression
		Jump = bJump, Expression
		Return = bReturn
			Expression = bExpression, ( Literal | VariableRef | FunctionCall | Operation )
				Literal = bLiteral, number
				VariableRef = bVariableRef, number
				FunctionCall = bFunctionCall, Expression+
				Operation = ( bReferenceOp
							| bDereferenceOp
							| bAddOp
							| bSubtractOp
							| bMultiplyOp
							| bDivideOp
							| bExponentOp
							| bModuloOp
							| bAndOp
							| bOrOp
							| bXorOp
							| bNotOp
							| bRotateLeftOp
							| bRotateRightOp ), Expression+

	identifier = ( ? utf-8 letter ? | "_" ), ( ? utf-8 letter ? | "_" | ? utf-8 digit ? )*
	identifier_number = number
	variable_number = number
	offset_number = number
	address = number
	number = WORD
	number_params = BYTE
	number_retval = BYTE

	special_identifiers = "_\n_sp\n_fp\n_ip\n_text\n_data\n"
	special_variables = 1, 2, 3, 4, 5, 6 // Each value 1 word in width
